Component A is root component. Component X is 5 level deep and Component Y is 8 level deep and both X and Y needs a common state. Why can't we use React Component Composition there instead of Context Provider?

---

Great question! You're hitting on a real limitation of component composition as a solution to prop drilling.

Component composition works beautifully in the example from the React docs because the structure is relatively **linear and predictable**. But when you have components at **different depths** that need the same data, composition breaks down. Let me show you why:

## The Problem with Different Depths

Let's say you have this structure:

```
A (root - has the state)
├── B
│   ├── C
│   │   ├── D
│   │   │   └── X (needs state) ← 5 levels deep
│   │   └── E
│   └── F
└── G
    └── H
        └── I
            └── J
                └── Y (needs state) ← 8 levels deep
```

## Why Composition Fails Here

With composition, you'd have to do something like:

```jsx
function A() {
  const [state, setState] = useState(someValue);
  
  return (
    <B>
      <C>
        <D>
          <X state={state} /> {/* Can pass it here */}
        </D>
        <E />
      </C>
      <F />
    </B>
    <G>
      <H>
        <I>
          <J>
            <Y state={state} /> {/* Can pass it here too */}
          </J>
        </I>
      </H>
    </G>
  );
}
```

**But this completely defeats the purpose!** Now:

1. **Component A knows too much** - It has to know about the internal structure of B, C, D, G, H, I, J. This violates encapsulation.

2. **You lose abstraction** - B, C, D, etc. can no longer decide their own internal structure. Everything has to be defined in A.

3. **It's not maintainable** - If you want to add a new level or change the structure, you have to modify component A.

## The Real Strength of Context

Context shines here because:

```jsx
function A() {
  const [state, setState] = useState(someValue);
  
  return (
    <MyContext.Provider value={state}>
      <B />
      <G />
    </MyContext.Provider>
  );
}

// Then in X (wherever it is in the tree):
function X() {
  const state = useContext(MyContext);
  // Use it!
}

// And in Y (at a different depth):
function Y() {
  const state = useContext(MyContext);
  // Use it!
}
```

Now **B, C, D, etc. maintain their encapsulation** - they don't need to know about or pass along this state. They can manage their own structure.

## When Composition Works

Composition works when:
- Components are at the **same depth** or in a **single branch**
- The parent **naturally knows** about its immediate children
- You're dealing with **layout/UI structure**, not deeply nested business logic

## TL;DR

Component composition is about "I'll let my parent decide what goes inside me." But when you need data at **unpredictable depths** across **different branches**, you can't use composition without destroying your component boundaries. That's exactly when Context becomes the right tool.
