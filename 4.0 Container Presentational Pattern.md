# Container/Presentational Pattern in React

## What Is This Pattern?

The Container/Presentational pattern is a simple way to organize your React components by splitting them into two types:

1. **Container Components** (Smart Components): Handle the logic, data fetching, and state management
2. **Presentational Components** (Dumb Components): Just display the UI and don't know where data comes from

Think of it like a restaurant:
- **Container** = The kitchen (prepares everything, handles the complicated stuff)
- **Presentational** = The waiter (just presents the food nicely, doesn't cook)

---

## The Problem: Components Doing Too Much

Let's look at a typical component that does everything:

```jsx
import { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch(`https://api.example.com/users/${userId}`)
      .then(response => response.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);

  if (loading) {
    return <div className="spinner">Loading...</div>;
  }

  if (error) {
    return <div className="error">Error: {error}</div>;
  }

  return (
    <div className="user-profile">
      <img 
        src={user.avatar} 
        alt={user.name}
        className="user-avatar"
      />
      <h2 className="user-name">{user.name}</h2>
      <p className="user-email">{user.email}</p>
      <p className="user-bio">{user.bio}</p>
      <div className="user-stats">
        <div>
          <strong>Posts:</strong> {user.posts}
        </div>
        <div>
          <strong>Followers:</strong> {user.followers}
        </div>
        <div>
          <strong>Following:</strong> {user.following}
        </div>
      </div>
    </div>
  );
}
```

**Problems with this approach:**
- ❌ Hard to reuse the UI with different data
- ❌ Difficult to test the UI without mocking API calls
- ❌ Can't easily preview the design without fetching data
- ❌ Logic and UI mixed together
- ❌ Can't use the same UI for different data sources

---

## The Solution: Separation

Let's split this into Container and Presentational components:

### Presentational Component (The UI)

```jsx
// UserProfileView.jsx
// This component ONLY cares about displaying data
// It doesn't know where the data comes from

function UserProfileView({ user }) {
  return (
    <div className="user-profile">
      <img 
        src={user.avatar} 
        alt={user.name}
        className="user-avatar"
      />
      <h2 className="user-name">{user.name}</h2>
      <p className="user-email">{user.email}</p>
      <p className="user-bio">{user.bio}</p>
      <div className="user-stats">
        <div>
          <strong>Posts:</strong> {user.posts}
        </div>
        <div>
          <strong>Followers:</strong> {user.followers}
        </div>
        <div>
          <strong>Following:</strong> {user.following}
        </div>
      </div>
    </div>
  );
}

export default UserProfileView;
```

### Container Component (The Logic)

```jsx
// UserProfileContainer.jsx
// This component ONLY cares about fetching and managing data
// It doesn't care how the data is displayed

import { useState, useEffect } from 'react';
import UserProfileView from './UserProfileView';

function UserProfileContainer({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch(`https://api.example.com/users/${userId}`)
      .then(response => response.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);

  if (loading) {
    return <div className="spinner">Loading...</div>;
  }

  if (error) {
    return <div className="error">Error: {error}</div>;
  }

  // Just pass the data to the presentational component
  return <UserProfileView user={user} />;
}

export default UserProfileContainer;
```

---

## Real Benefits: Why This Matters

### 1. **Reusability**

Now you can use the same UI with different data sources:

```jsx
// From API
<UserProfileContainer userId={123} />

// From props (maybe parent already has the data)
function UserPage({ userData }) {
  return <UserProfileView user={userData} />;
}

// From local storage
function SavedProfile() {
  const savedUser = JSON.parse(localStorage.getItem('user'));
  return <UserProfileView user={savedUser} />;
}

// With mock data in Storybook
<UserProfileView user={mockUserData} />
```

### 2. **Easy Testing**

Testing the UI becomes super simple:

```jsx
// Test the presentational component (no mocking needed!)
test('displays user name', () => {
  const mockUser = {
    name: 'John Doe',
    email: 'john@example.com',
    avatar: 'avatar.jpg',
    bio: 'Hello!',
    posts: 10,
    followers: 100,
    following: 50
  };

  render(<UserProfileView user={mockUser} />);
  expect(screen.getByText('John Doe')).toBeInTheDocument();
});

// Test the container component (focus on data fetching)
test('fetches user data', async () => {
  // Mock the API
  // Test the logic
});
```

### 3. **Design and Development in Parallel**

Designers can work on the presentational component with mock data while developers build the container logic:

```jsx
// Designer working on UserProfileView.jsx with mock data
const mockUser = {
  name: 'Jane Smith',
  email: 'jane@example.com',
  // ... etc
};

<UserProfileView user={mockUser} />

// Developer working on UserProfileContainer.jsx separately
// Both can merge their work later
```

### 4. **Easier to Understand**

When reading code:
- Look at **Presentational** to understand WHAT is displayed
- Look at **Container** to understand WHERE data comes from

---

## More Practical Examples

### Example: Todo List

#### Presentational Component

```jsx
// TodoList.jsx
function TodoList({ todos, onToggle, onDelete }) {
  return (
    <ul className="todo-list">
      {todos.map(todo => (
        <li key={todo.id} className={todo.completed ? 'completed' : ''}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => onToggle(todo.id)}
          />
          <span>{todo.text}</span>
          <button onClick={() => onDelete(todo.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

#### Container Component

```jsx
// TodoListContainer.jsx
import { useState, useEffect } from 'react';
import TodoList from './TodoList';

function TodoListContainer() {
  const [todos, setTodos] = useState([]);

  useEffect(() => {
    // Fetch todos from API
    fetch('https://api.example.com/todos')
      .then(res => res.json())
      .then(data => setTodos(data));
  }, []);

  const handleToggle = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const handleDelete = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <TodoList 
      todos={todos}
      onToggle={handleToggle}
      onDelete={handleDelete}
    />
  );
}
```

### Example: Weather Widget

#### Presentational Component

```jsx
// WeatherDisplay.jsx
function WeatherDisplay({ weather }) {
  return (
    <div className="weather-widget">
      <h2>{weather.city}</h2>
      <div className="temperature">{weather.temp}°C</div>
      <div className="condition">{weather.condition}</div>
      <div className="details">
        <span>Humidity: {weather.humidity}%</span>
        <span>Wind: {weather.wind} km/h</span>
      </div>
    </div>
  );
}
```

#### Container Component

```jsx
// WeatherContainer.jsx
import { useState, useEffect } from 'react';
import WeatherDisplay from './WeatherDisplay';

function WeatherContainer({ city }) {
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    setLoading(true);
    fetch(`https://api.weather.com/current?city=${city}`)
      .then(res => res.json())
      .then(data => {
        setWeather(data);
        setLoading(false);
      });
  }, [city]);

  if (loading) return <div>Loading weather...</div>;

  return <WeatherDisplay weather={weather} />;
}
```

---

## Quick Rules of Thumb

### Presentational Components Should:
- ✅ Receive data via props
- ✅ Focus on how things look
- ✅ Have no dependencies on data fetching
- ✅ Be easy to test with mock data
- ✅ Usually be functional components
- ✅ Contain mostly JSX and styling

### Container Components Should:
- ✅ Handle data fetching and state management
- ✅ Focus on how things work
- ✅ Pass data down to presentational components
- ✅ Contain logic, API calls, useEffect hooks
- ✅ Have minimal UI (or just render presentational components)

---

## When to Use This Pattern?

**✅ Use when:**
- You need to reuse the same UI with different data sources
- You want to test UI without complex setup
- You're building a design system or component library
- Multiple people are working on the same feature
- You want clean separation of concerns

**❌ Don't use when:**
- Component is very simple (like a button)
- Data and UI are tightly coupled
- It makes code more complex without clear benefit
- You're using modern hooks that already separate concerns well

---

## Modern Note: Hooks Changed Things

With React Hooks, we now have other ways to separate logic:

```jsx
// Custom hook for logic (similar to container)
function useUserProfile(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch(`https://api.example.com/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, [userId]);
  
  return { user, loading };
}

// Component for presentation
function UserProfile({ userId }) {
  const { user, loading } = useUserProfile(userId);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

Both patterns achieve similar goals - the Container/Presentational pattern is still valuable for understanding component organization!

---

## Summary

**Container/Presentational pattern** = Splitting components into "smart" ones that handle logic and "dumb" ones that handle display.

**Key benefit**: Your UI becomes reusable, testable, and easier to understand because logic and presentation are separated.

**Remember**: The kitchen prepares the food (Container), the waiter presents it (Presentational). Each has one job, and they do it well!
