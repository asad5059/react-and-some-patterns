# React Compound Component Pattern

## The Problem: Props Explosion

Let's start with a simple `ProductCard` component and see how it becomes unmanageable as requirements grow.

### Version 1: Simple Component

```jsx
function ProductCard({ product }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>{product.description}</p>
      <span>${product.price}</span>
      <button>Add to Cart</button>
    </div>
  );
}
```

### Version 2: Adding Flags

Soon, different pages need different variations:

```jsx
function ProductCard({ 
  product,
  showImage = true,
  showDescription = true,
  showPrice = true,
  showButton = true,
  imageSize = 'medium'
}) {
  return (
    <div className="product-card">
      {showImage && (
        <img 
          src={product.image} 
          alt={product.name}
          className={`image-${imageSize}`}
        />
      )}
      <h3>{product.name}</h3>
      {showDescription && <p>{product.description}</p>}
      {showPrice && <span>${product.price}</span>}
      {showButton && <button>Add to Cart</button>}
    </div>
  );
}
```

### Version 3: Order Control (Getting Messy)

Now marketing wants to reorder elements:

```jsx
function ProductCard({ 
  product,
  showImage = true,
  showDescription = true,
  showPrice = true,
  showButton = true,
  imageSize = 'medium',
  layout = 'default', // 'default' | 'price-first' | 'compact'
  buttonText = 'Add to Cart',
  onButtonClick,
  showBadge = false,
  badgeText,
  showRating = false
}) {
  const renderContent = () => {
    switch (layout) {
      case 'price-first':
        return (
          <>
            {showPrice && <span className="price">${product.price}</span>}
            <h3>{product.name}</h3>
            {showDescription && <p>{product.description}</p>}
          </>
        );
      case 'compact':
        return (
          <>
            <h3>{product.name}</h3>
            {showPrice && <span className="price-inline">${product.price}</span>}
          </>
        );
      default:
        return (
          <>
            <h3>{product.name}</h3>
            {showDescription && <p>{product.description}</p>}
            {showPrice && <span className="price">${product.price}</span>}
          </>
        );
    }
  };

  return (
    <div className={`product-card layout-${layout}`}>
      {showBadge && <div className="badge">{badgeText}</div>}
      {showImage && (
        <img 
          src={product.image} 
          alt={product.name}
          className={`image-${imageSize}`}
        />
      )}
      {showRating && (
        <div className="rating">★ {product.rating}</div>
      )}
      {renderContent()}
      {showButton && (
        <button onClick={onButtonClick}>
          {buttonText}
        </button>
      )}
    </div>
  );
}

// Usage becomes overwhelming:
<ProductCard
  product={product}
  showImage={true}
  showDescription={false}
  showPrice={true}
  showButton={true}
  imageSize="large"
  layout="price-first"
  buttonText="Buy Now"
  showBadge={true}
  badgeText="Sale!"
  showRating={true}
  onButtonClick={handleAddToCart}
/>
```

**Problems:**
- 12+ props and growing
- Complex internal logic with switches and conditionals
- Poor flexibility - new layouts require modifying the component
- Hard to maintain and test
- Props drilling nightmare
- Component knows too much about its structure

---

## The Solution: Compound Component Pattern

The compound component pattern allows you to create flexible, composable components where parent and children share implicit state.

### Implementation

```jsx
import { createContext, useContext, useState } from 'react';

// 1. Create context for shared state
const ProductCardContext = createContext();

// 2. Custom hook for accessing context
function useProductCardContext() {
  const context = useContext(ProductCardContext);
  if (!context) {
    throw new Error('ProductCard compound components must be used within ProductCard');
  }
  return context;
}

// 3. Main component (Provider)
function ProductCard({ children, product, onAddToCart }) {
  const [quantity, setQuantity] = useState(1);

  const value = {
    product,
    quantity,
    setQuantity,
    onAddToCart
  };

  return (
    <ProductCardContext.Provider value={value}>
      <div className="product-card">
        {children}
      </div>
    </ProductCardContext.Provider>
  );
}

// 4. Sub-components
ProductCard.Image = function ProductCardImage({ size = 'medium' }) {
  const { product } = useProductCardContext();
  return (
    <img 
      src={product.image} 
      alt={product.name}
      className={`product-image-${size}`}
    />
  );
};

ProductCard.Badge = function ProductCardBadge({ children }) {
  return <div className="product-badge">{children}</div>;
};

ProductCard.Title = function ProductCardTitle() {
  const { product } = useProductCardContext();
  return <h3 className="product-title">{product.name}</h3>;
};

ProductCard.Description = function ProductCardDescription() {
  const { product } = useProductCardContext();
  return <p className="product-description">{product.description}</p>;
};

ProductCard.Price = function ProductCardPrice() {
  const { product } = useProductCardContext();
  return <span className="product-price">${product.price}</span>;
};

ProductCard.Rating = function ProductCardRating() {
  const { product } = useProductCardContext();
  return (
    <div className="product-rating">
      ★ {product.rating}/5
    </div>
  );
};

ProductCard.AddToCart = function ProductCardAddToCart({ children = 'Add to Cart' }) {
  const { product, quantity, onAddToCart } = useProductCardContext();
  
  return (
    <button 
      className="add-to-cart-btn"
      onClick={() => onAddToCart(product, quantity)}
    >
      {children}
    </button>
  );
};

ProductCard.Quantity = function ProductCardQuantity() {
  const { quantity, setQuantity } = useProductCardContext();
  
  return (
    <div className="quantity-selector">
      <button onClick={() => setQuantity(Math.max(1, quantity - 1))}>-</button>
      <span>{quantity}</span>
      <button onClick={() => setQuantity(quantity + 1)}>+</button>
    </div>
  );
};
```

### Usage: Complete Flexibility

```jsx
// Default Layout
<ProductCard product={product} onAddToCart={handleAddToCart}>
  <ProductCard.Image />
  <ProductCard.Title />
  <ProductCard.Description />
  <ProductCard.Price />
  <ProductCard.AddToCart />
</ProductCard>

// Price-First Layout
<ProductCard product={product} onAddToCart={handleAddToCart}>
  <ProductCard.Badge>Sale!</ProductCard.Badge>
  <ProductCard.Image size="large" />
  <ProductCard.Price />
  <ProductCard.Title />
  <ProductCard.Rating />
  <ProductCard.AddToCart>Buy Now</ProductCard.AddToCart>
</ProductCard>

// Compact Layout
<ProductCard product={product} onAddToCart={handleAddToCart}>
  <ProductCard.Image size="small" />
  <ProductCard.Title />
  <ProductCard.Price />
</ProductCard>

// Complex Layout with Quantity
<ProductCard product={product} onAddToCart={handleAddToCart}>
  <ProductCard.Badge>Featured</ProductCard.Badge>
  <ProductCard.Image size="large" />
  <div className="product-info">
    <ProductCard.Title />
    <ProductCard.Rating />
    <ProductCard.Description />
  </div>
  <div className="product-actions">
    <ProductCard.Price />
    <ProductCard.Quantity />
    <ProductCard.AddToCart />
  </div>
</ProductCard>

// Custom Wrapper
<ProductCard product={product} onAddToCart={handleAddToCart}>
  <div className="custom-grid">
    <ProductCard.Image />
    <div>
      <ProductCard.Title />
      <ProductCard.Price />
    </div>
  </div>
</ProductCard>
```

---

## Pros and Cons

### ✅ Pros

**1. Flexibility**
- Users compose components however they want
- No need to modify the base component for new layouts
- Easy to add/remove/reorder elements

**2. Cleaner API**
- No props explosion
- Self-documenting component structure
- Clear what's being rendered by looking at JSX

**3. Separation of Concerns**
- Each sub-component handles one thing
- Main component manages shared state
- Logic is distributed appropriately

**4. Extensibility**
- Easy to add new sub-components without breaking existing code
- Users can create custom sub-components
- Compose with other components naturally

**5. Better IntelliSense**
- IDEs can autocomplete sub-components
- TypeScript support is straightforward
- Less prop validation needed

**6. Implicit State Sharing**
- Sub-components automatically access shared state
- No prop drilling
- Clean parent-child communication

### ❌ Cons

**1. Learning Curve**
- More complex pattern to understand
- Developers need to know about Context API
- Not immediately intuitive for beginners

**2. More Boilerplate**
- Requires Context setup
- More code upfront
- Multiple component definitions

**3. Less Control**
- Users can compose incorrectly
- May need validation to prevent invalid compositions
- Harder to enforce certain layouts

**4. Performance Considerations**
- Context re-renders all consumers when value changes
- Need to memoize context value if performance is critical
- More components in the tree

**5. Testing Complexity**
- Must test compositions, not just isolated component
- Need to test sub-components within context
- More scenarios to cover

**6. Documentation Burden**
- Need to document all sub-components
- Must explain proper usage patterns
- Examples are crucial for adoption

---

## When to Use Compound Components

**✅ Use when:**
- Component has many display variations
- Users need full control over layout and ordering
- Component parts need to share state
- Building a component library or design system
- Flexibility is more important than consistency

**❌ Avoid when:**
- Component is simple with few variations
- Layout should be strictly controlled
- Team is unfamiliar with advanced React patterns
- Performance is critical and re-renders are expensive
- You need guaranteed component structure

---

## Best Practices

1. **Provide Default Composition**: Create a default export for common use cases
2. **Validate Context**: Always check if context exists to provide helpful errors
3. **Document Examples**: Show multiple composition patterns
4. **Type Everything**: Use TypeScript for better DX
5. **Consider Performance**: Memoize context values when needed
6. **Namespace Sub-components**: Use `Component.SubComponent` pattern
7. **Keep State Minimal**: Only share what's necessary in context

---

## Conclusion

The compound component pattern transforms rigid, prop-heavy components into flexible, composable building blocks. While it adds complexity, the payoff in flexibility and maintainability is substantial for components with high variation needs.

Start with simple components and refactor to compound components when you notice props explosion or layout inflexibility. Your component library users will thank you for the flexibility!
