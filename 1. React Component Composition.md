
## Understanding React Component Composition

When building a React app, one of the key ideas is **composition** — combining smaller, reusable components to create more complex UIs.

Instead of creating one big, complicated component, React encourages us to break the UI into small, focused pieces and **compose** them together.
This approach makes our code **cleaner**, **easier to maintain**, and **more reusable**.

---

### What is Component Composition?

**Component composition** means using one component **inside another**.

Think of it like Lego blocks — each piece does one thing well, but when you put them together, you can build anything.

In React, we typically compose components using **children** or **props**.

---

### Example 1: Basic Composition

Let’s start with a simple example — a reusable **Card** component.

```jsx
// Card.js
function Card({ children }) {
  return (
    <div style={{
      border: '1px solid #ddd',
      borderRadius: '8px',
      padding: '16px',
      boxShadow: '0 2px 6px rgba(0,0,0,0.1)',
      margin: '16px 0'
    }}>
      {children}
    </div>
  );
}

export default Card;
```

Now you can use it like this:

```jsx
// App.js
import Card from './Card';

function App() {
  return (
    <div>
      <Card>
        <h2>Welcome!</h2>
        <p>This is a reusable Card component using composition.</p>
      </Card>

      <Card>
        <img src="https://placekitten.com/200/200" alt="Cute kitten" />
        <p>Here’s a card with an image instead!</p>
      </Card>
    </div>
  );
}
```

The `Card` doesn’t need to know what’s inside — it simply wraps whatever content you provide.

---

### Example 2: Avoiding “Prop Drilling”

Sometimes, we pass the same prop through many components just to reach a deeply nested one.

For example, consider a Page component that passes a user and avatarSize prop several levels down so that deeply nested Link and Avatar components can read it:

```jsx
<Page user={user} avatarSize={avatarSize} />
// ... which renders ...
<PageLayout user={user} avatarSize={avatarSize} />
// ... which renders ...
<NavigationBar user={user} avatarSize={avatarSize} />
// ... which renders ...
<Link href={user.permalink}>
  <Avatar user={user} size={avatarSize} />
</Link>
```
It might feel redundant to pass down the `user` and `avatarSize` props through many levels if in the end only the `Avatar` component really needs it. 
It’s also annoying that whenever the `Avatar` component needs more props from the top, you have to add them at all the intermediate levels too.

<br>
One way to solve this issue without `context` is to pass down the Avatar component itself so that the intermediate components don’t need to know about the `user` or `avatarSize` props:

```jsx
function Page(props) {
  const user = props.user;
  const userLink = (
    <Link href={user.permalink}>
      <Avatar user={user} size={props.avatarSize} />
    </Link>
  );
  return <PageLayout userLink={userLink} />;
}

// Now, we have:
<Page user={user} avatarSize={avatarSize} />
// ... which renders ...
<PageLayout userLink={...} />
// ... which renders ...
<NavigationBar userLink={...} />
// ... which renders ...
{props.userLink}
```

With this change, only the top-most `Page` component needs to know about the `Link` and `Avatar` components’ use of `user` and `avatarSize`.

---

### Why Use Composition?

1. Encourages **reusability**
2. Keeps code **modular** and **maintainable**
3. Avoids **prop drilling** in many cases
4. Makes UI structure **flexible**

---
